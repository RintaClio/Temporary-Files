
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Document Link</title>
        </head>
        <body>
            <h1>Welcome! Please check the following code</h1>
            <p>```<br>**resnet50**<br><br>Unknown language "py"  <br>import torch  <br>import torch.nn as nn  <br>import torchvision  <br>import torchvision.transforms as transforms  <br><br><br>\# Device configuration  <br>device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')  <br>print("device: "+str(device))  <br>\# Hyper-parameters  <br>num_epochs = 20  <br>learning_rate = 0.001  <br><br>\# Image preprocessing modules  <br>transform = transforms.Compose([  <br> transforms.Pad(4),  <br> transforms.RandomHorizontalFlip(),  <br> transforms.RandomCrop(32),  <br> transforms.ToTensor()])  <br><br>\# CIFAR-10 dataset  <br>train_dataset = torchvision.datasets.CIFAR10(root='./dataset/',  <br> train=True,  <br> transform=transform,  <br> download=True)  <br><br>test_dataset = torchvision.datasets.CIFAR10(root='./dataset/',  <br> train=False,  <br> transform=transforms.ToTensor())  <br><br>\# Data loader  <br>train_loader = torch.utils.data.DataLoader(dataset=train_dataset,  <br> batch_size=100,  <br> shuffle=True)  <br><br>test_loader = torch.utils.data.DataLoader(dataset=test_dataset,  <br> batch_size=100,  <br> shuffle=False)  <br><br>\# 3x3 convolution  <br>def conv3x3(in_channels, out_channels, stride=1):  <br> return nn.Conv2d(in_channels, out_channels, kernel_size=3,  <br> stride=stride, padding=1, bias=False)  <br><br>\# Residual block  <br>class ResidualBlock(nn.Module):  <br> def \__init__(self, in_channels, out_channels, stride=1, downsample=None):  <br> super(ResidualBlock, self).__init__()  <br> self.conv1 = conv3x3(in_channels, out_channels, stride)  <br> self.bn1 = nn.BatchNorm2d(out_channels)  <br> self.relu = nn.ReLU(inplace=True)  <br> self.conv2 = conv3x3(out_channels, out_channels)  <br> self.bn2 = nn.BatchNorm2d(out_channels)  <br> self.downsample = downsample  <br><br> def forward(self, x):  <br> residual = x  <br> out = self.conv1(x)  <br> out = self.bn1(out)  <br> out = self.relu(out)  <br> out = self.conv2(out)  <br> out = self.bn2(out)  <br> if self.downsample:  <br> residual = self.downsample(x)  <br> out += residual  <br> out = self.relu(out)  <br> return out  <br><br>\# ResNet  <br>class ResNet(nn.Module):  <br> def \__init__(self, block, layers, num_classes=10):  <br> super(ResNet, self).__init__()  <br> self.in_channels = 16  <br> self.conv = conv3x3(3, 16)  <br> self.bn = nn.BatchNorm2d(16)  <br> self.relu = nn.ReLU(inplace=True)  <br> self.layer1 = self.make_layer(block, 16, layers[0])  <br> self.layer2 = self.make_layer(block, 32, layers[1], 2)  <br> self.layer3 = self.make_layer(block, 64, layers[2], 2)  <br> self.avg_pool = nn.AvgPool2d(8)  <br> self.fc = nn.Linear(64, num_classes)  <br><br> def make_layer(self, block, out_channels, blocks, stride=1):  <br> downsample = None  <br> if (stride != 1) or (self.in_channels != out_channels):  <br> downsample = nn.Sequential(  <br> conv3x3(self.in_channels, out_channels, stride=stride),  <br> nn.BatchNorm2d(out_channels))  <br> layers = []  <br> layers.append(block(self.in_channels, out_channels, stride, downsample))  <br> self.in_channels = out_channels  <br> for i in range(1, blocks):  <br> layers.append(block(out_channels, out_channels))  <br> return nn.Sequential(\*layers)  <br><br> def forward(self, x):  <br> out = self.conv(x)  <br> out = self.bn(out)  <br> out = self.relu(out)  <br> out = self.layer1(out)  <br> out = self.layer2(out)  <br> out = self.layer3(out)  <br> out = self.avg_pool(out)  <br> out = out.view(out.size(0), -1)  <br> out = self.fc(out)  <br> return out  <br><br>model = ResNet(ResidualBlock, [2, 2, 2]).to(device)  <br><br><br>\# Loss and optimizer  <br>criterion = nn.CrossEntropyLoss()  <br>optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)  <br><br>\# For updating learning rate  <br>def update_lr(optimizer, lr):   <br> for param_group in optimizer.param_groups:  <br> param_group['lr'] = lr  <br><br>\# Train the model  <br>total_step = len(train_loader)  <br>curr_lr = learning_rate  <br>for epoch in range(num_epochs):  <br> for i, (images, labels) in enumerate(train_loader):  <br> images = images.to(device)  <br> labels = labels.to(device)  <br><br> \# Forward pass  <br> outputs = model(images)  <br> loss = criterion(outputs, labels)  <br><br> \# Backward and optimize  <br> optimizer.zero_grad()  <br> loss.backward()  <br> optimizer.step()  <br><br> if (i+1) % 100 == 0:  <br> print ("Epoch [{}/{}], Step [{}/{}] Loss: {:.4f}"  <br> .format(epoch+1, num_epochs, i+1, total_step, loss.item()))  <br><br> \# Decay learning rate  <br> if (epoch+1) % 10 == 0:  <br> curr_lr /= 3  <br> update_lr(optimizer, curr_lr)  <br><br>\# Test the model  <br>model.eval()  <br>with torch.no_grad():  <br> correct = 0  <br> total = 0  <br> for images, labels in test_loader:  <br> images = images.to(device)  <br> labels = labels.to(device)  <br> outputs = model(images)  <br> \_, predicted = torch.max(outputs.data, 1)  <br> total += labels.size(0)  <br> correct += (predicted == labels).sum().item()  <br><br> print('Accuracy of the model on the test images: {} %'.format(100 \* correct / total))  <br><br>\# Save the model checkpoint  <br>torch.save(model.state_dict(), 'resnet.ckpt')<br><br>```<br></p>
        </body>
        </html>
        